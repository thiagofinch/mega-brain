---
phase: 04-task-orchestrator
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - core/intelligence/task_orchestrator.py
  - .claude/mission-control/ORCHESTRATOR-STATE.json
  - logs/orchestrator-execution.jsonl
autonomous: true
requirements: [ORCH-03]

must_haves:
  truths:
    - "Orchestrator reports current_task name during execution"
    - "Orchestrator reports progress percentage (completed/total)"
    - "Orchestrator reports estimated_remaining time"
    - "Execution log is saved after each workflow run"
  artifacts:
    - path: "core/intelligence/task_orchestrator.py"
      provides: "Progress reporting and CLI interface"
      exports: ["TaskOrchestrator", "get_progress", "run_workflow"]
    - path: ".claude/mission-control/ORCHESTRATOR-STATE.json"
      provides: "Execution state persistence"
      contains: "current_phase"
    - path: "logs/orchestrator-execution.jsonl"
      provides: "Execution history log"
      contains: "event_type"
  key_links:
    - from: "core/intelligence/task_orchestrator.py"
      to: ".claude/mission-control/ORCHESTRATOR-STATE.json"
      via: "state persistence"
      pattern: "json\\.dump"
    - from: "core/intelligence/task_orchestrator.py"
      to: "logs/orchestrator-execution.jsonl"
      via: "JSONL logging"
      pattern: "log_execution"
---

<objective>
Add progress reporting and CLI interface to the task orchestrator, completing ORCH-03 requirements.

Purpose: Enable real-time monitoring of workflow execution with current_task, progress%, and estimated_remaining metrics.

Output: Enhanced task_orchestrator.py with progress reporting methods and CLI commands.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-task-orchestrator/04-01-SUMMARY.md

<interfaces>
<!-- From Plan 04-01: TaskOrchestrator class interface -->
```python
class TaskOrchestrator:
    def __init__(self, workflow_id: str): ...
    def execute(self, inputs: Dict[str, Any]) -> Dict[str, Any]: ...
    def _execute_phase(self, phase: WorkflowPhase, inputs: Dict) -> Dict: ...
    def get_current_task(self) -> Optional[TaskDefinition]: ...
    def mark_task_complete(self, task_id: str, outputs: Dict) -> None: ...
```

<!-- From Plan 04-01: ExecutionState structure -->
```python
@dataclass
class ExecutionState:
    workflow_id: str
    current_phase: str
    current_step: int
    status: str  # pending, running, complete, failed
    history: List[Dict]
    started_at: Optional[str]
    completed_at: Optional[str]
```

<!-- CLI pattern from pipeline_checkpoint.py -->
```python
def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    if command == 'status':
        show_status()
    elif command == 'run':
        run_workflow(sys.argv[2] if len(sys.argv) > 2 else None)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress tracking and reporting methods</name>
  <files>core/intelligence/task_orchestrator.py</files>
  <action>
Extend `core/intelligence/task_orchestrator.py` with progress reporting:

1. **Add ProgressReport dataclass:**
   ```python
   @dataclass
   class ProgressReport:
       current_task: str
       current_phase: str
       progress_percent: float
       tasks_completed: int
       tasks_total: int
       estimated_remaining_seconds: Optional[int]
       started_at: str
       elapsed_seconds: int
   ```

2. **Add timing tracking to ExecutionState:**
   - Add `task_timings: Dict[str, float]` to track seconds per task
   - Add `phase_started_at: Optional[str]` for phase timing

3. **Implement progress methods in TaskOrchestrator:**

   ```python
   def get_progress(self) -> ProgressReport:
       """
       Calculate and return current execution progress.

       Returns:
           ProgressReport with current_task, progress%, estimated_remaining
       """
       total_tasks = sum(len(p.steps) for p in self.workflow.phases)
       completed = self._count_completed_tasks()
       progress = (completed / total_tasks * 100) if total_tasks > 0 else 0

       # Calculate estimated remaining from average task time
       avg_time = self._calculate_avg_task_time()
       remaining_tasks = total_tasks - completed
       estimated_remaining = int(avg_time * remaining_tasks) if avg_time else None

       return ProgressReport(
           current_task=self._get_current_task_name(),
           current_phase=self.state.current_phase or "not_started",
           progress_percent=round(progress, 1),
           tasks_completed=completed,
           tasks_total=total_tasks,
           estimated_remaining_seconds=estimated_remaining,
           started_at=self.state.started_at or "",
           elapsed_seconds=self._calculate_elapsed()
       )

   def _count_completed_tasks(self) -> int:
       """Count tasks marked complete in history."""

   def _calculate_avg_task_time(self) -> float:
       """Calculate average task execution time from timings."""

   def _get_current_task_name(self) -> str:
       """Get the name of the current task being executed."""

   def _calculate_elapsed(self) -> int:
       """Calculate elapsed seconds since workflow started."""
   ```

4. **Update execute methods to record timing:**
   - Start timer when entering _execute_step
   - Record timing when task completes
   - Save timing to state.task_timings

5. **Add log_execution calls at key points:**
   - workflow_started
   - phase_started
   - task_started
   - task_completed
   - phase_completed
   - workflow_completed
   - error
  </action>
  <verify>
python3 -c "
import sys
sys.path.insert(0, 'core/intelligence')
from task_orchestrator import TaskOrchestrator, ProgressReport

# Instantiate and check progress method exists
orch = TaskOrchestrator('wf-ingest')
progress = orch.get_progress()

assert isinstance(progress, ProgressReport), 'get_progress must return ProgressReport'
assert hasattr(progress, 'current_task'), 'ProgressReport missing current_task'
assert hasattr(progress, 'progress_percent'), 'ProgressReport missing progress_percent'
assert hasattr(progress, 'estimated_remaining_seconds'), 'ProgressReport missing estimated_remaining'
print(f'Progress: {progress.progress_percent}% - {progress.current_task}')
print('Progress reporting verified!')
"
  </verify>
  <done>
- ProgressReport dataclass exists with all required fields
- get_progress() returns valid ProgressReport
- Timing tracking integrated into execution flow
- JSONL logging captures all key events
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI interface for orchestrator</name>
  <files>core/intelligence/task_orchestrator.py</files>
  <action>
Add CLI interface to `task_orchestrator.py` (at bottom of file):

1. **CLI Commands:**

   ```python
   def print_usage():
       print("""
   Task Orchestrator - Mega Brain Pipeline
   ========================================

   Usage:
       python3 task_orchestrator.py <command> [args]

   Commands:
       list                    List available workflows
       status                  Show current execution status
       run <workflow_id>       Run a workflow (e.g., wf-ingest)
       progress                Show progress of current execution
       reset                   Reset orchestrator state

   Examples:
       python3 task_orchestrator.py list
       python3 task_orchestrator.py run wf-ingest
       python3 task_orchestrator.py status
       """)

   def cmd_list():
       """List available workflows."""
       print("[JARVIS] Available workflows:")
       for wf_path in list_workflows():
           wf = load_workflow(wf_path)
           phases = len(wf.phases)
           print(f"  - {wf.id}: {wf.name} ({phases} phases)")

   def cmd_status():
       """Show current execution status."""
       state = load_state()
       if not state:
           print("[JARVIS] No active execution. Run a workflow first.")
           return

       print("[JARVIS] Orchestrator Status")
       print(f"  Workflow: {state.workflow_id}")
       print(f"  Phase: {state.current_phase or 'not started'}")
       print(f"  Status: {state.status}")
       print(f"  Started: {state.started_at or 'N/A'}")

   def cmd_run(workflow_id: str):
       """Run a workflow."""
       print(f"[JARVIS] Starting workflow: {workflow_id}")
       orch = TaskOrchestrator(workflow_id)
       # Note: Actual execution requires Claude agent
       # This initializes state and shows what will run
       progress = orch.get_progress()
       print(f"  Total tasks: {progress.tasks_total}")
       print(f"  Current task: {progress.current_task}")
       print("[JARVIS] Workflow ready. Execute with Claude agent.")

   def cmd_progress():
       """Show progress of current execution."""
       state = load_state()
       if not state:
           print("[JARVIS] No active execution.")
           return

       orch = TaskOrchestrator(state.workflow_id)
       orch.state = state
       progress = orch.get_progress()

       print("[JARVIS] Execution Progress")
       print(f"  Current Task: {progress.current_task}")
       print(f"  Progress: {progress.progress_percent}%")
       print(f"  Completed: {progress.tasks_completed}/{progress.tasks_total} tasks")
       if progress.estimated_remaining_seconds:
           mins = progress.estimated_remaining_seconds // 60
           secs = progress.estimated_remaining_seconds % 60
           print(f"  Estimated Remaining: {mins}m {secs}s")
       print(f"  Elapsed: {progress.elapsed_seconds}s")

   def cmd_reset():
       """Reset orchestrator state."""
       if STATE_PATH.exists():
           STATE_PATH.unlink()
       print("[JARVIS] Orchestrator state reset.")

   def main():
       if len(sys.argv) < 2:
           print_usage()
           sys.exit(1)

       command = sys.argv[1].lower()

       if command == 'list':
           cmd_list()
       elif command == 'status':
           cmd_status()
       elif command == 'run':
           if len(sys.argv) < 3:
               print("[ERROR] Usage: run <workflow_id>")
               sys.exit(1)
           cmd_run(sys.argv[2])
       elif command == 'progress':
           cmd_progress()
       elif command == 'reset':
           cmd_reset()
       else:
           print(f"[ERROR] Unknown command: {command}")
           print_usage()
           sys.exit(1)

   if __name__ == '__main__':
       main()
   ```

2. **Ensure proper imports at top of file:**
   - sys for CLI args
   - Ensure Path, datetime, json are imported

3. **Test all CLI commands work without error.**
  </action>
  <verify>
# Test CLI commands
echo "=== Testing CLI commands ===" &&
python3 core/intelligence/task_orchestrator.py list &&
echo "" &&
python3 core/intelligence/task_orchestrator.py status &&
echo "" &&
python3 core/intelligence/task_orchestrator.py run wf-ingest &&
echo "" &&
python3 core/intelligence/task_orchestrator.py progress &&
echo "" &&
echo "=== All CLI commands executed ==="
  </verify>
  <done>
- CLI interface works with all commands: list, status, run, progress, reset
- 'list' shows all 4 workflows
- 'status' shows current state or "no active execution"
- 'run' initializes workflow and shows tasks
- 'progress' shows current_task, progress%, estimated_remaining
  </done>
</task>

<task type="auto">
  <name>Task 3: Create execution log and verify state persistence</name>
  <files>
    - .claude/mission-control/ORCHESTRATOR-STATE.json
    - logs/orchestrator-execution.jsonl
  </files>
  <action>
1. **Create initial ORCHESTRATOR-STATE.json:**
   Run the orchestrator to create the state file:
   ```bash
   python3 core/intelligence/task_orchestrator.py run wf-ingest
   ```

2. **Verify state file structure:**
   Check that .claude/mission-control/ORCHESTRATOR-STATE.json contains:
   - workflow_id
   - current_phase
   - current_step
   - status
   - started_at
   - task_timings

3. **Verify log file is created:**
   Check that logs/orchestrator-execution.jsonl exists and contains valid JSONL entries.

4. **Test state persistence:**
   - Run `status` command, verify it reads state correctly
   - Run `progress` command, verify it reads state and calculates progress
   - Run `reset` command, verify state is cleared

5. **Document the integration in a brief test:**
   Create execution log entries for:
   - workflow_init event
   - state_saved event
  </action>
  <verify>
python3 -c "
import json
from pathlib import Path

# Check state file
state_path = Path('.claude/mission-control/ORCHESTRATOR-STATE.json')
assert state_path.exists(), 'ORCHESTRATOR-STATE.json should exist after run'
state = json.loads(state_path.read_text())
assert 'workflow_id' in state, 'State missing workflow_id'
assert 'status' in state, 'State missing status'
print(f'State file valid: workflow={state.get(\"workflow_id\")}')

# Check log file (may or may not exist yet)
log_path = Path('logs/orchestrator-execution.jsonl')
if log_path.exists():
    lines = log_path.read_text().strip().split('\n')
    for line in lines[-3:]:  # Check last 3 entries
        entry = json.loads(line)
        assert 'timestamp' in entry or 'event_type' in entry
    print(f'Log file valid: {len(lines)} entries')
else:
    print('Log file will be created on first execution')

print('State persistence verified!')
"
  </verify>
  <done>
- ORCHESTRATOR-STATE.json exists with valid structure
- State persists between CLI commands
- Execution log captures key events
- ORCH-03 complete: Reports progress (current_task, progress%, estimated_remaining)
  </done>
</task>

</tasks>

<verification>
1. `python3 core/intelligence/task_orchestrator.py list` shows 4 workflows
2. `python3 core/intelligence/task_orchestrator.py run wf-ingest` initializes execution
3. `python3 core/intelligence/task_orchestrator.py progress` shows current_task, progress%, estimated_remaining
4. ORCHESTRATOR-STATE.json contains valid workflow execution state
5. logs/orchestrator-execution.jsonl contains execution events
</verification>

<success_criteria>
- ORCH-03: Task orchestrator reports progress âœ“
  - current_task: Name of task being executed
  - progress%: Percentage of tasks completed
  - estimated_remaining: Calculated from average task time
- CLI interface fully functional
- Execution log saved after each run
</success_criteria>

<output>
After completion, create `.planning/phases/04-task-orchestrator/04-02-SUMMARY.md`
</output>
