---
phase: 11-package-sync
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - .npmignore
  - .github/layer1-allowlist.txt
autonomous: true
requirements:
  - SYNC-02
must_haves:
  truths:
    - ".npmignore excludes all L2/L3/NEVER patterns identified by the audit"
    - ".npmignore does not exclude any L1 content that is in the package.json files field"
    - "layer1-allowlist.txt matches the package.json files field (single source of truth)"
    - "npm pack --dry-run output is unchanged after .npmignore update (defense-in-depth, not additive)"
  artifacts:
    - path: ".npmignore"
      provides: "Defense-in-depth exclusion rules aligned with audit classifications"
    - path: ".github/layer1-allowlist.txt"
      provides: "Human-readable L1 allowlist synced with package.json files field"
  key_links:
    - from: ".npmignore"
      to: "package.json"
      via: "defense-in-depth — .npmignore is the second layer, files field is primary"
      pattern: "files field is the primary whitelist"
    - from: ".github/layer1-allowlist.txt"
      to: "package.json"
      via: "mirrors files field for CI and human review"
      pattern: "SYNCED WITH: package.json"
---

<objective>
Regenerate `.npmignore` from audit classifications and sync `layer1-allowlist.txt` with the new package.json files field.

Purpose: `.npmignore` is defense-in-depth — it shouldn't be the primary filter (that's `files`), but it must be consistent. Currently 232 hand-curated lines that may drift from the audit. The allowlist is used by CI and human reviewers.
Output: Updated `.npmignore` aligned with audit + updated `layer1-allowlist.txt` matching files field.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-package-sync/11-01-PLAN.md

<interfaces>
<!-- From Plan 01: sync_package_files.py produces the files array -->
<!-- From audit_layers.py: L2_PATTERNS, L3_PATTERNS, NEVER_PATTERNS define what to exclude -->

From core/intelligence/audit_layers.py:
```python
L2_PATTERNS = [
    'agents/minds/', 'agents/cargo/',
    'knowledge/dossiers/', 'knowledge/playbooks/', 'knowledge/dna/', 'knowledge/sources/',
    'artifacts/insights/', 'artifacts/chunks/', 'artifacts/extractions/',
]

L3_PATTERNS = [
    'inbox/', 'logs/',
    '.claude/sessions/', '.claude/mission-control/',
    'agents/sua-empresa/',
]

NEVER_PATTERNS = [
    '.env', 'credentials.json', 'token.json',
    '.key', '.pem', '.secret',
    '.mcp.json', 'settings.local.json',
    'node_modules/', '.DS_Store',
]
```

Current .npmignore: 232 lines, hand-curated, organized by category.
Current layer1-allowlist.txt: 114 lines, manually maintained, header says "SYNCED WITH: package.json files field".
</interfaces>

<analysis>
## .npmignore Strategy

The `.npmignore` serves as defense-in-depth. With `files` as the primary whitelist, `.npmignore` is technically redundant for INCLUSION — npm only packs what's in `files`. However, `.npmignore` serves two purposes:

1. **Exclude patterns within included directories** — If `files` includes `core/` but `core/__pycache__/` should never ship, `.npmignore` catches it
2. **Documentation** — Makes the exclusion rules visible and auditable

The regenerated `.npmignore` should:
- Use audit layer patterns (L2, L3, NEVER) as the source of truth
- Add build artifact patterns (__pycache__, .pyc, etc.)
- Add OS/IDE patterns (.DS_Store, .vscode, etc.)
- Keep the existing category-based organization for readability
- NOT include patterns that `files` already handles (if `agents/minds/` isn't in `files`, no need to add it to `.npmignore`)

## layer1-allowlist.txt Strategy

This file should exactly mirror the package.json `files` field, formatted as one entry per line with comments. The sync script from Plan 01 is the source — read package.json files field and format it.
</analysis>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate .npmignore from audit classifications</name>
  <files>.npmignore</files>
  <action>
Regenerate `.npmignore` using audit layer patterns as the source of truth. The file should be organized by category with clear comments.

**Structure:**

```
# ===========================================
# .npmignore - Mega Brain npm package
# ===========================================
# AUTO-GENERATED from audit layer classifications.
# Source of truth: core/intelligence/audit_layers.py
# Regenerate: python3 core/intelligence/sync_package_files.py --npmignore
#
# Defense-in-depth: package.json "files" is the
# primary whitelist. This file is the SECOND layer.
# ===========================================

# === PYTHON BUILD ARTIFACTS (NEVER ship) ===
__pycache__/
**/__pycache__/
**/*.pyc
**/*.pyo
**/*.pyd
*.egg-info/

# === L2 CONTENT (Premium — not in public package) ===
# Source: L2_PATTERNS in audit_layers.py
agents/minds/
agents/cargo/
knowledge/dossiers/
knowledge/playbooks/
knowledge/dna/
knowledge/sources/
artifacts/insights/
artifacts/chunks/
artifacts/extractions/

# === L3 CONTENT (Personal — never distributed) ===
# Source: L3_PATTERNS in audit_layers.py
inbox/
logs/
.claude/sessions/
.claude/mission-control/
agents/sua-empresa/

# === NEVER CONTENT (Secrets/sensitive) ===
# Source: NEVER_PATTERNS in audit_layers.py
.env
.env.*
credentials.json
token.json
*.key
*.pem
*.secret
.mcp.json
settings.local.json
node_modules/

# === DEVELOPMENT-ONLY (not for consumers) ===
.planning/
docs/audit/
docs/plans/
docs/validation/

# === RUNTIME STATE (per-user, not template) ===
.claude/agent-memory/
.claude/monitoring/
.claude/learning-system/
.claude/aios/
.claude/jarvis/STATE.json
.claude/jarvis/DECISIONS-LOG.md
.claude/jarvis/CONTEXT-STACK.json
.claude/jarvis/PENDING.md
.claude/jarvis/CURRENT-TASK.md
.claude/settings.local.json
.claude/audit-*.json

# === COMPANY-SPECIFIC CONTENT ===
.claude/skills/ask-company/
.claude/skills/process-company-inbox/
.claude/skills/*-company-*

# === L2-ONLY SKILLS (premium layer) ===
.claude/skills/council/
.claude/skills/executor/
.claude/skills/fase-2-5-tagging/
.claude/skills/finance-agent/
.claude/skills/gdrive-transcription-downloader/
.claude/skills/hybrid-source-reading/
.claude/skills/ler-planilha/
.claude/skills/smart-download-tagger/
.claude/skills/source-sync/
.claude/skills/sync-docs/
.claude/skills/talent-agent/
.claude/skills/chronicler/
.claude/skills/gemini-fallback/
.claude/skills/jarvis/
.claude/skills/jarvis-briefing/
.claude/skills/resume/
.claude/skills/save/
.claude/skills/verify/

# === MEDIA FILES ===
*.mp4
*.mp3
*.wav
*.m4a
*.mov
*.avi
*.mkv

# === LARGE/BINARY FILES ===
*.b64
*.db
*.sqlite
*.pdf
*.zip
*.tar
*.gz
*.bz2

# === OS & IDE ===
.DS_Store
Thumbs.db
.vscode/
.idea/
.obsidian/

# === BUILD ARTIFACTS ===
dist/
build/
.venv*/
venv/
vendor/
chroma_db/
.chroma/

# === BACKUPS & TEMP ===
*_BACKUP_*.py
*.bak
*.tmp

# === GIT (npm handles this, but explicit) ===
.git/
```

**IMPORTANT:** Add `--npmignore` subcommand to `sync_package_files.py` so the `.npmignore` can also be regenerated programmatically. The script should:
1. Read `L2_PATTERNS`, `L3_PATTERNS`, `NEVER_PATTERNS` from audit_layers.py
2. Combine with hardcoded build artifact and OS patterns
3. Write the .npmignore file

Add this function to `sync_package_files.py`:

```python
def generate_npmignore(repo_root: Path) -> str:
    """Generate .npmignore content from audit layer classifications."""
    # Import patterns directly from audit_layers
    from audit_layers import L2_PATTERNS, L3_PATTERNS, NEVER_PATTERNS
    # Build the .npmignore content with categories
    # Return as string
```

Then update the CLI to support:
```
python3 core/intelligence/sync_package_files.py --npmignore          # Print to stdout
python3 core/intelligence/sync_package_files.py --npmignore --apply  # Write to .npmignore
```

Write the `.npmignore` using the script output, review it, and verify it doesn't exclude any L1 content.

**Verification after writing:**
```bash
# Verify .npmignore doesn't block L1 content
# The files field is the primary whitelist, so npm pack should be unchanged
npm pack --dry-run --json 2>/dev/null | python3 -c "
import json, sys
data = json.loads(sys.stdin.read())
files = [f['path'] for f in data[0]['files']]
print(f'{len(files)} files in pack')
"
```
  </action>
  <verify>
    <automated>npm pack --dry-run --json 2>/dev/null | python3 -c "
import json, sys
sys.path.insert(0, 'core/intelligence')
from audit_layers import classify_path
from pathlib import Path
pack = json.loads(sys.stdin.read())
files = [f['path'] for f in pack[0]['files']]
repo = Path('.')
bad = [(f,classify_path(repo/f,repo,True)[0]) for f in files if classify_path(repo/f,repo,True)[0] not in ('L1',)]
if bad:
    for f,l in bad[:10]: print(f'  [{l}] {f}')
    print(f'FAIL')
    sys.exit(1)
print(f'PASS: {len(files)} pack files, all L1')
"</automated>
  </verify>
  <done>.npmignore is regenerated from audit classifications, organized by category, and npm pack output contains only L1 content (defense-in-depth verified)</done>
</task>

<task type="auto">
  <name>Task 2: Sync layer1-allowlist.txt with package.json files field</name>
  <files>.github/layer1-allowlist.txt</files>
  <action>
Regenerate `.github/layer1-allowlist.txt` to exactly mirror the package.json `files` field.

Read the current package.json `files` array (as updated by Plan 01) and format it into `layer1-allowlist.txt` with:
- Header comments explaining the file's purpose
- "SYNCED WITH: package.json files field" in header
- "AUTO-GENERATED" notice with regeneration command
- One entry per line, grouped by category with comment headers
- Same ordering as the files array

**Format:**

```
# Layer 1 Allowlist - PUBLIC content (free/community)
# ==============================================================
# AUTO-GENERATED from package.json files field.
# Regenerate: python3 core/intelligence/sync_package_files.py --allowlist
#
# ONLY paths listed here are included in Layer 1 (public repo).
# Everything else is PREMIUM by default (Layer 2+).
#
# SYNCED WITH: package.json "files" field
# AUDITED: [date]
# ==============================================================

[entries from package.json files field, one per line]
```

Add `--allowlist` subcommand to `sync_package_files.py`:

```python
def generate_allowlist(files_array: list, repo_root: Path) -> str:
    """Generate layer1-allowlist.txt from package.json files array."""
    # Group entries by top-level directory
    # Add category comments
    # Return formatted string
```

CLI:
```
python3 core/intelligence/sync_package_files.py --allowlist          # Print to stdout
python3 core/intelligence/sync_package_files.py --allowlist --apply  # Write to file
```

Also update `layer2-manifest.txt` header to note it was reviewed against the audit (no content changes needed — its content is correct per the audit L2 patterns).

**Verification:**
```bash
# Verify allowlist entries match package.json files exactly
python3 -c "
import json
with open('package.json') as f: pkg = json.load(f)
with open('.github/layer1-allowlist.txt') as f:
    lines = [l.strip() for l in f if l.strip() and not l.startswith('#')]
pkg_files = set(pkg['files'])
allowlist = set(lines)
if pkg_files != allowlist:
    missing = pkg_files - allowlist
    extra = allowlist - pkg_files
    if missing: print(f'Missing from allowlist: {missing}')
    if extra: print(f'Extra in allowlist: {extra}')
else:
    print(f'PASS: {len(pkg_files)} entries match')
"
```
  </action>
  <verify>
    <automated>python3 -c "
import json
with open('package.json') as f: pkg = json.load(f)
with open('.github/layer1-allowlist.txt') as f:
    lines = [l.strip() for l in f if l.strip() and not l.startswith('#')]
pkg_set = set(pkg['files'])
allow_set = set(lines)
diff = pkg_set.symmetric_difference(allow_set)
if diff:
    print(f'FAIL: {len(diff)} differences: {diff}')
    import sys; sys.exit(1)
print(f'PASS: {len(pkg_set)} entries match between package.json and allowlist')
"</automated>
  </verify>
  <done>layer1-allowlist.txt exactly mirrors package.json files field, with auto-generation header and category comments. layer2-manifest.txt header updated.</done>
</task>

</tasks>

<verification>
CHECK 1: .npmignore excludes L2/L3/NEVER content
  grep -c "agents/minds/" .npmignore
  grep -c "inbox/" .npmignore
  grep -c "\.env" .npmignore
  Expected: all > 0

CHECK 2: .npmignore does NOT exclude L1 content in files field
  npm pack --dry-run --json 2>/dev/null | python3 -c "
  import json, sys
  data = json.loads(sys.stdin.read())
  print(f'{len(data[0][\"files\"])} files in pack — all should be L1')
  "

CHECK 3: layer1-allowlist.txt matches package.json files
  (see Task 2 verify command)

CHECK 4: All three artifacts are regenerable
  python3 core/intelligence/sync_package_files.py --print > /dev/null && echo "files: OK"
  python3 core/intelligence/sync_package_files.py --npmignore > /dev/null && echo "npmignore: OK"
  python3 core/intelligence/sync_package_files.py --allowlist > /dev/null && echo "allowlist: OK"
</verification>

<success_criteria>
- .npmignore aligns with audit classifications (L2/L3/NEVER excluded)
- .npmignore does not block any L1 content from being packed
- layer1-allowlist.txt exactly mirrors package.json files field
- All three outputs (files, npmignore, allowlist) are regenerable from one script
</success_criteria>

<output>
After completion, create `.planning/phases/11-package-sync/11-02-SUMMARY.md`
</output>
