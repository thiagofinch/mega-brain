---
phase: 02-cascading-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/scripts/validate_cascading_integrity.py
autonomous: true
requirements:
  - VAL-01
  - VAL-02

must_haves:
  truths:
    - "Script validates if batch destinations exist on filesystem"
    - "Script validates if destinations reference the batch ID"
    - "Script returns JSON with status, errors, warnings"
    - "Exit code 0 for PASSED, 1 for FAILED"
  artifacts:
    - path: ".claude/scripts/validate_cascading_integrity.py"
      provides: "Cascading validation logic"
      min_lines: 200
  key_links:
    - from: ".claude/scripts/validate_cascading_integrity.py"
      to: "logs/batches/BATCH-*.md"
      via: "file glob and content parsing"
      pattern: "logs/batches"
    - from: ".claude/scripts/validate_cascading_integrity.py"
      to: "agents/*/MEMORY.md"
      via: "destination resolution"
      pattern: "agents.*MEMORY"
---

<objective>
Implement validate_cascading_integrity.py script that replaces the current stub.

Purpose: Enable automated validation that batch cascading actually updated destination files (agents, playbooks, dossiers, DNAs).

Output: Fully functional Python script that validates cascading integrity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Reference implementation (archive): archive/auditoria-2026-01/auditoria/scripts-validation/validate_cascading_integrity.py

Current project paths:
- Batches: logs/batches/BATCH-*.md
- Agents: agents/{cargo,minds,boardroom,sua-empresa}/*/MEMORY.md
- Playbooks: knowledge/playbooks/PLAYBOOK-*.md
- Dossiers: knowledge/dossiers/**/*.md
- DNAs: knowledge/dna/persons/*/DNA.yaml

Batch format example (from logs/batches/BATCH-050.md):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸš€ DESTINO DO CONHECIMENTO                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ğŸ¤– AGENTES A ALIMENTAR:                                                   â”‚
â”‚      â€¢ AGENT-SALES-LEADER.md (gestÃ£o de times)                             â”‚
â”‚   ğŸ“˜ PLAYBOOKS IMPACTADOS:                                                  â”‚
â”‚      â€¢ PLAYBOOK-CONTRATACAO.md                                             â”‚
â”‚   ğŸ§¬ DNAs ENRIQUECIDOS:                                                     â”‚
â”‚      â€¢ DNA-CG.md (+42 elementos)                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement validate_cascading_integrity.py</name>
  <files>.claude/scripts/validate_cascading_integrity.py</files>
  <action>
Replace the current 6-line stub with a full implementation. The script must:

1. **Configuration section** (~20 lines):
   - PROJECT_ROOT = Path of project (use relative paths from script location)
   - LOGS_PATH = PROJECT_ROOT / "logs"
   - BATCHES_PATH = LOGS_PATH / "batches"
   - AGENTS_PATH = PROJECT_ROOT / "agents"
   - PLAYBOOKS_PATH = PROJECT_ROOT / "knowledge" / "playbooks"
   - DOSSIERS_PATH = PROJECT_ROOT / "knowledge" / "dossiers"
   - DNA_PATH = PROJECT_ROOT / "knowledge" / "dna"
   - VERIFIED_LOG = LOGS_PATH / "cascading-verified.jsonl"

2. **Destination extraction** (~100 lines):
   - `extract_destinations_from_batch(content: str) -> Dict[str, List[str]]`
   - Parse ASCII box format with emojis (ğŸ¤– AGENTES, ğŸ“˜ PLAYBOOKS, ğŸ§¬ DNAs)
   - Extract agent names from patterns like `â€¢ AGENT-SALES-LEADER.md`
   - Extract playbook names from patterns like `â€¢ PLAYBOOK-CONTRATACAO.md`
   - Extract DNA names from patterns like `â€¢ DNA-CG.md`
   - Return dict with keys: agents, playbooks, dossiers, dnas

3. **Path resolution** (~60 lines):
   - `resolve_agent_path(agent_name: str) -> Optional[Path]`
     Search in: agents/cargo/*/, agents/minds/*/, agents/boardroom/*/, agents/sua-empresa/*/
     Look for MEMORY.md or AGENT.md files
   - `resolve_playbook_path(playbook_name: str) -> Optional[Path]`
     Search in: knowledge/playbooks/PLAYBOOK-{name}.md
   - `resolve_dossier_path(dossier_name: str) -> Optional[Path]`
     Search in: knowledge/dossiers/**/DOSSIER-{name}.md
   - `resolve_dna_path(dna_name: str) -> Optional[Path]`
     Search in: knowledge/dna/persons/{name}/DNA.yaml

4. **Validation logic** (~80 lines):
   - `validate_batch_integrity(batch_id: str) -> Dict`:
     - Check if batch file exists
     - Check if "Cascateamento Executado" or "cascading" section exists
     - Extract destinations
     - Check if each destination file exists
     - Check if destination files reference the batch ID
     - Return JSON with: status (PASSED/FAILED/WARNING), batch_id, errors[], warnings[], destinations_detail{}

5. **CLI interface** (~40 lines):
   - Accept batch_id as argument (e.g., BATCH-050 or just 050)
   - Accept --json flag for JSON output
   - Accept --all flag to validate all batches
   - Exit 0 for PASSED, exit 1 for FAILED

Use Python 3 stdlib only (pathlib, json, re, sys, datetime). Follow project convention: snake_case, use pathlib.Path.
  </action>
  <verify>
    <automated>python3 .claude/scripts/validate_cascading_integrity.py BATCH-050 --json 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print('status:', d.get('status')); sys.exit(0 if d.get('status') else 1)"</automated>
  </verify>
  <done>
Script validates BATCH-050 and returns JSON with status field. Script has 200+ lines of implementation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate script with multiple batches</name>
  <files>.claude/scripts/validate_cascading_integrity.py</files>
  <action>
Test the script against 3 different batches to ensure robustness:
1. Run against BATCH-050 (known good format)
2. Run against BATCH-083 (another batch)
3. Run against BATCH-001-JEREMY-HAYNES-SOPS-20260104 (different naming format)

Fix any edge cases discovered:
- Handle batch IDs with dates (BATCH-001-JEREMY-HAYNES-SOPS-20260104)
- Handle batches without cascading section (return WARNING)
- Handle batches with no destinations (return WARNING)

Add summary output when run without arguments:
```
Validating all batches...
Total: 145
PASSED: 120
WARNING: 15
FAILED: 10
```
  </action>
  <verify>
    <automated>python3 .claude/scripts/validate_cascading_integrity.py --json 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print('total:', d.get('total')); sys.exit(0 if 'total' in d else 1)"</automated>
  </verify>
  <done>
Script handles multiple batch formats. Script runs against all batches and returns summary JSON with total count.
  </done>
</task>

</tasks>

<verification>
1. Script file exists and has 200+ lines
2. Running `python3 .claude/scripts/validate_cascading_integrity.py BATCH-050 --json` returns valid JSON
3. JSON output contains: status, batch_id, destinations_total, errors, warnings
4. Running without args validates all batches and returns summary
5. Exit code is 0 for PASSED/WARNING, 1 for FAILED
</verification>

<success_criteria>
- VAL-01 complete: validate_cascading_integrity.py is fully implemented (not a stub)
- VAL-02 complete: Script returns PASSED/FAILED/WARNING status with errors[] and warnings[]
- Script validates destination existence and batch reference
- CLI supports single batch and all-batches modes
</success_criteria>

<output>
After completion, create `.planning/phases/02-cascading-validation/02-01-SUMMARY.md`
</output>
