---
phase: 12-validation-and-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/validate-package.js
  - bin/pre-publish-gate.js
  - package.json
autonomous: true
requirements:
  - VAL-01
  - VAL-02
  - VAL-03
must_haves:
  truths:
    - "Running `node bin/validate-package.js` compares npm pack --dry-run output against L1 audit classifications and prints PASSED or FAILED"
    - "npm pack --dry-run produces a file list containing only L1 content (no L2/L3/NEVER files)"
    - "The pre-publish gate (prepublishOnly) exits 0 on a clean package and exits 1 if layer violations or secrets are found"
    - "Running validate-package.js when package is clean exits 0; when a non-L1 file would be packed, exits 1 with details"
  artifacts:
    - path: "bin/validate-package.js"
      provides: "Standalone validation script comparing npm pack output vs L1 audit"
      contains: "npm pack --dry-run"
    - path: "bin/pre-publish-gate.js"
      provides: "Enhanced pre-publish gate with both secrets scan AND L1 layer validation"
      contains: "layer validation"
  key_links:
    - from: "bin/validate-package.js"
      to: "core/intelligence/audit_layers.py"
      via: "Runs audit_layers.py to get L1 classifications, compares with npm pack output"
      pattern: "audit_layers"
    - from: "bin/pre-publish-gate.js"
      to: "bin/validate-package.js"
      via: "Pre-publish gate imports/calls the validation logic"
      pattern: "validate"
    - from: "package.json"
      to: "bin/pre-publish-gate.js"
      via: "prepublishOnly script reference"
      pattern: "prepublishOnly"
---

<objective>
Create a validation script that compares npm pack output against L1 audit classifications, and enhance the pre-publish gate to include layer validation alongside the existing secrets scan.

Purpose: Automated verification that the npm package contains ONLY L1 content. This is the final gate before `npm publish` — if a non-L1 file sneaks into the package, the gate catches it.
Output: `bin/validate-package.js` (standalone validator) + enhanced `bin/pre-publish-gate.js` (unified gate).
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-package-sync/11-01-PLAN.md

<interfaces>
<!-- Phase 11 creates sync_package_files.py which uses these interfaces from audit_layers.py -->

From core/intelligence/audit_layers.py:
```python
def classify_path(path: Path, repo_root: Path, is_file: bool) -> Tuple[str, str]:
    """Classify a path into a layer. Returns: (layer, reason)"""

def scan_repository(repo_root: Path, verbose: bool = False) -> Dict:
    """Scan entire repository and classify all items.
    Returns: {
        'summary': {'total_items': int, 'by_layer': {'L1': int, ...}},
        'classifications': [{'path': str, 'layer': str, 'type': str, 'reason': str}, ...],
        'delete_candidates': [...],
        'review_needed': [...]
    }
    """
```

From bin/pre-publish-gate.js (existing — secrets scan):
```javascript
// ESM module (import syntax)
// Runs as "prepublishOnly": "node bin/pre-publish-gate.js"
// Gets pack files via: npm pack --dry-run --json
// Checks file names against FORBIDDEN_FILE_PATTERNS
// Checks file contents against SECRET_PATTERNS
// Exits 0 (pass) or 1 (blocked)
```

From package.json:
```json
{
  "type": "module",
  "scripts": {
    "prepublishOnly": "node bin/pre-publish-gate.js"
  }
}
```

CRITICAL: Phase 11 runs in parallel. When Phase 12 executes, `sync_package_files.py` will exist and `package.json` files field will be audit-derived. The validation script should call `audit_layers.py` via Python subprocess (not import it — JS calling Python).
</interfaces>

<analysis>
## Strategy

The validation script needs to:
1. Run `npm pack --dry-run --json` to get the list of files that WOULD be published
2. Run `python3 core/intelligence/audit_layers.py` (or call classify_path) to get L1 classifications
3. Cross-reference: every file in the pack output must be L1
4. Report PASSED/FAILED with details on any violations

Two deployment modes:
- **Standalone**: `node bin/validate-package.js` — developers run manually to check
- **Pre-publish gate**: integrated into `prepublishOnly` hook — runs automatically before `npm publish`

The existing `pre-publish-gate.js` already gets the pack file list and scans for secrets. We EXTEND it with layer validation rather than replacing it. The standalone script can be imported by the gate.

Since package.json uses `"type": "module"`, all JS files use ESM imports.

## Validation approach

Rather than importing Python from Node.js, the validator will:
1. Run `python3 -c "..."` subprocess to get L1 file list from audit
2. Run `npm pack --dry-run --json` to get pack file list
3. Compare the two sets
4. Any file in pack but NOT in L1 = violation

Alternatively (simpler and more reliable): run `python3 core/intelligence/sync_package_files.py --print` to get the expected files array, then compare with what npm pack would produce. If they match, PASSED.

Actually, the most robust approach: for each file in `npm pack --dry-run` output, call `classify_path()` via Python subprocess and verify it's L1. This catches edge cases where a file exists on disk but isn't in the audit.
</analysis>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bin/validate-package.js</name>
  <files>bin/validate-package.js</files>
  <action>
Create `bin/validate-package.js` — a standalone Node.js ESM script that validates the npm package contains only L1 content.

**Shebang and imports:**
```javascript
#!/usr/bin/env node

/**
 * Mega Brain — Package Layer Validation
 *
 * Compares npm pack --dry-run output against L1 audit classifications.
 * Reports PASSED or FAILED with details on any non-L1 files.
 *
 * Usage:
 *   node bin/validate-package.js          # Validate and report
 *   node bin/validate-package.js --json   # JSON output for CI
 *
 * Exit codes:
 *   0 = PASSED (all files are L1)
 *   1 = FAILED (non-L1 files found)
 *   2 = ERROR (could not run validation)
 */

import { execSync } from 'child_process';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
```

**Core logic:**

1. **Get pack files:** Run `npm pack --dry-run --json` (same approach as existing pre-publish-gate.js), extract the file list.

2. **Classify each file:** Run a single Python subprocess that classifies all pack files at once. Create a small inline Python script that imports `classify_path` from `audit_layers.py` and classifies a list of paths:

```javascript
const classifyScript = `
import sys, json
sys.path.insert(0, '${resolve(PROJECT_ROOT, 'core/intelligence')}')
from pathlib import Path
from audit_layers import classify_path

repo = Path('${PROJECT_ROOT}')
paths = json.loads(sys.stdin.read())
results = {}
for p in paths:
    layer, reason = classify_path(repo / p, repo, is_file=True)
    results[p] = {"layer": layer, "reason": reason}
print(json.dumps(results))
`;

const input = JSON.stringify(packFiles);
const result = execSync(`python3 -c '${classifyScript}'`, {
  input,
  encoding: 'utf-8',
  cwd: PROJECT_ROOT,
});
const classifications = JSON.parse(result);
```

IMPORTANT: Use a heredoc-style approach for the Python script to avoid shell quoting issues. Write the Python script to a temp file, execute it, then clean up. Or use `execSync` with `input` option to pass the file list via stdin and embed the script inline using double quotes carefully.

Actually, the SIMPLEST and most robust approach: write a small Python helper script inline, pass file list via stdin:

```javascript
// Write a temp Python script that reads stdin (JSON file list) and classifies each
const pythonScript = [
  'import sys, json',
  `sys.path.insert(0, ${JSON.stringify(resolve(PROJECT_ROOT, 'core/intelligence'))})`,
  'from pathlib import Path',
  'from audit_layers import classify_path',
  `repo = Path(${JSON.stringify(PROJECT_ROOT)})`,
  'paths = json.loads(sys.stdin.read())',
  'results = {}',
  'for p in paths:',
  '    layer, reason = classify_path(repo / p, repo, is_file=True)',
  '    results[p] = {"layer": layer, "reason": reason}',
  'print(json.dumps(results))',
].join('\n');

const classifyResult = execSync('python3 -c ' + JSON.stringify(pythonScript), {
  input: JSON.stringify(packFiles),
  encoding: 'utf-8',
  cwd: PROJECT_ROOT,
  stdio: ['pipe', 'pipe', 'pipe'],
});
```

3. **Evaluate results:** Iterate classifications. Any file with layer !== 'L1' is a violation. Collect violations.

4. **Report:**
   - If `--json` flag: output JSON `{ "status": "PASSED"|"FAILED", "total_files": N, "violations": [...] }`
   - Otherwise: human-readable report with colored output

```
[validate] Scanning 156 pack files against L1 audit...
[validate] ✅ PASSED: All 156 files are L1

or

[validate] Scanning 156 pack files against L1 audit...
[validate] ❌ FAILED: 3 non-L1 files found:
  [L2] agents/minds/alex-hormozi/AGENT.md — L2 premium content
  [L3] .claude/sessions/SESSION-2026.md — L3 personal data
  [NEVER] .env — NEVER: secrets file
```

5. **Exit codes:** 0 = PASSED, 1 = FAILED, 2 = ERROR (e.g., python not found, audit_layers.py not found)

6. **Export the validation function** so pre-publish-gate.js can import it:

```javascript
export async function validatePackage(projectRoot) {
  // ... core logic ...
  return { status, totalFiles, violations };
}
```

Also export it as a default CLI runner when invoked directly:

```javascript
// CLI entry point
const isDirectRun = process.argv[1] && resolve(process.argv[1]) === resolve(fileURLToPath(import.meta.url));
if (isDirectRun) {
  // run validation and print report
}
```

**Add npm script** to package.json:
```json
"scripts": {
  "validate:layers": "node bin/validate-package.js"
}
```
  </action>
  <verify>
    <automated>node bin/validate-package.js --json 2>/dev/null | python3 -c "
import json, sys
data = json.loads(sys.stdin.read())
assert data['status'] in ('PASSED', 'FAILED'), f'Unexpected status: {data[\"status\"]}'
assert 'total_files' in data, 'Missing total_files'
assert 'violations' in data, 'Missing violations'
print(f'Status: {data[\"status\"]}, Files: {data[\"total_files\"]}, Violations: {len(data[\"violations\"])}')
if data['status'] == 'PASSED':
    print('PASS')
    sys.exit(0)
else:
    print(f'FAIL: {len(data[\"violations\"])} violations')
    sys.exit(1)
"</automated>
  </verify>
  <done>bin/validate-package.js exists, compares npm pack output against L1 audit, reports PASSED/FAILED with details, exits 0 on clean package, exits 1 on violations, and exports validatePackage function for pre-publish gate</done>
</task>

<task type="auto">
  <name>Task 2: Enhance pre-publish-gate.js with layer validation</name>
  <files>bin/pre-publish-gate.js, package.json</files>
  <action>
Enhance the existing `bin/pre-publish-gate.js` to run layer validation IN ADDITION to the existing secrets scan. Do NOT replace the secrets scan — ADD the layer check as a new step.

**Changes to pre-publish-gate.js:**

1. Import the validation function from validate-package.js:
```javascript
import { validatePackage } from './validate-package.js';
```

2. Add a new STEP between the existing steps (after getting pack files, before the verdict). Insert as STEP 3 (renumber existing steps):

```javascript
// === STEP 3: Layer validation (L1 only) ===
console.log(`${CYAN}[pre-publish] Running layer validation...${NC}`);
try {
  const validation = await validatePackage(PROJECT_ROOT);
  if (validation.status === 'FAILED') {
    console.error(`${RED}[BLOCKED] ${validation.violations.length} non-L1 files in package:${NC}`);
    for (const v of validation.violations) {
      console.error(`${RED}  [${v.layer}] ${v.path} — ${v.reason}${NC}`);
    }
    foundIssues += validation.violations.length;
  } else {
    console.log(`${GREEN}[pre-publish] Layer validation PASSED: ${validation.totalFiles} files, all L1.${NC}`);
  }
} catch (err) {
  // Layer validation is best-effort in pre-publish gate
  // If Python or audit_layers.py not available, WARN but don't block
  console.warn(`${YELLOW}[pre-publish] Layer validation skipped: ${err.message}${NC}`);
  console.warn(`${YELLOW}[pre-publish] Run 'node bin/validate-package.js' manually to validate.${NC}`);
}
```

IMPORTANT: The layer validation requires Python 3 and `audit_layers.py` to exist. In a consumer's machine (after `npm install`), these might not be available. So the layer validation step should:
- **In pre-publish (maintainer context):** Run and BLOCK if violations found
- **If Python not available:** WARN but don't block (graceful degradation)
- The secrets scan (Steps 3-4 in original) still runs regardless and BLOCKS independently

3. Since `validatePackage` is async, make the main script async. The existing pre-publish-gate.js is synchronous. Wrap the existing code in an async IIFE or convert to top-level await (ESM supports this):

```javascript
// At the top of the file, after existing code, add the layer check:
// The existing sync code runs first (steps 1-4 original)
// Then the async layer validation runs
// Then the verdict

// Option: Keep existing sync code intact, add async layer check at the end
// before the verdict section
```

Actually, looking at the existing code, it's already top-level code (not wrapped in async). The simplest approach:
- Make `validatePackage` SYNCHRONOUS (use `execSync` not `exec`) so it fits naturally into the existing sync flow
- This avoids restructuring the entire pre-publish-gate.js

Update `validate-package.js` to export a SYNC function `validatePackageSync(projectRoot)` alongside the async one.

4. Add `validate:layers` script to package.json:
```json
"scripts": {
  "validate:layers": "node bin/validate-package.js",
  "prepublishOnly": "node bin/pre-publish-gate.js"
}
```

The `prepublishOnly` script stays the same — it already points to pre-publish-gate.js which now includes layer validation.

**Do NOT change:** The existing secrets scan logic (SECRET_PATTERNS, FORBIDDEN_FILE_PATTERNS, trufflehog). Only ADD the layer validation step.
  </action>
  <verify>
    <automated>node bin/pre-publish-gate.js 2>&1 | grep -E "(Layer validation PASSED|Layer validation skipped|Security gate PASSED|BLOCKED)" && echo "PASS: pre-publish gate runs with layer validation"</automated>
  </verify>
  <done>pre-publish-gate.js runs both secrets scan AND layer validation. Exits 0 when package is clean (no secrets, all L1). Exits 1 if secrets found OR non-L1 files detected. Layer validation degrades gracefully if Python unavailable. package.json has validate:layers script.</done>
</task>

</tasks>

<verification>
CHECK 1: Standalone validation works
  node bin/validate-package.js
  Expected: PASSED with file count, exit code 0

CHECK 2: JSON output mode works
  node bin/validate-package.js --json
  Expected: JSON with status, total_files, violations fields

CHECK 3: Pre-publish gate includes layer validation
  node bin/pre-publish-gate.js 2>&1 | grep "Layer validation"
  Expected: "Layer validation PASSED" message appears

CHECK 4: Pre-publish gate still checks secrets
  node bin/pre-publish-gate.js 2>&1 | grep "Security gate"
  Expected: "Security gate PASSED" message appears

CHECK 5: Exit codes are correct
  node bin/validate-package.js; echo "Exit: $?"
  Expected: Exit: 0

CHECK 6: validate:layers script works
  npm run validate:layers 2>&1 | grep "PASSED\|FAILED"
  Expected: PASSED or FAILED status
</verification>

<success_criteria>
- bin/validate-package.js compares npm pack output against L1 audit classifications
- Validation reports PASSED when all pack files are L1, FAILED when non-L1 files found
- pre-publish-gate.js runs both secrets scan AND layer validation
- Pre-publish gate exits 0 on clean package, exits 1 on any violation
- Layer validation degrades gracefully if Python not available (warn, don't block)
- npm run validate:layers works as standalone check
</success_criteria>

<output>
After completion, create `.planning/phases/12-validation-and-docs/12-01-SUMMARY.md`
</output>
