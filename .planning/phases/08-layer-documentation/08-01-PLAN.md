---
phase: 08-layer-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/LAYERS.md
  - docs/audit/L1-GITIGNORE-TEMPLATE.txt
  - docs/audit/L2-GITIGNORE-TEMPLATE.txt
  - docs/audit/L3-GITIGNORE-TEMPLATE.txt
autonomous: true
requirements:
  - DOC-01
  - DOC-02
  - DOC-03

must_haves:
  truths:
    - "Any person can classify a new file by reading LAYERS.md"
    - "Each layer has clear .gitignore patterns"
    - "Classification criteria are explicit with examples"
  artifacts:
    - path: "docs/LAYERS.md"
      provides: "Complete layer documentation"
      min_lines: 150
    - path: "docs/audit/L1-GITIGNORE-TEMPLATE.txt"
      provides: ".gitignore for L1 (Community) distribution"
      contains: "# L1 Community"
    - path: "docs/audit/L2-GITIGNORE-TEMPLATE.txt"
      provides: ".gitignore for L2 (Premium) distribution"
      contains: "# L2 Premium"
    - path: "docs/audit/L3-GITIGNORE-TEMPLATE.txt"
      provides: ".gitignore for L3 (Personal) backup"
      contains: "# L3 Personal"
  key_links:
    - from: "docs/LAYERS.md"
      to: "audit_layers.py"
      via: "Classification rules reference"
      pattern: "audit_layers.py"
---

<objective>
Create comprehensive layer documentation that enables anyone to correctly classify files into L1/L2/L3/NEVER/DELETE/REVIEW categories.

Purpose: Enable consistent file classification for npm packaging (L1), premium distribution (L2), and personal backups (L3).
Output: LAYERS.md documentation + .gitignore templates per layer
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/audit/AUDIT-REPORT.json (real examples from Phase 7)
@core/intelligence/audit_layers.py (classification logic source)
@.gitignore (existing layer patterns)
@.planning/phases/08-layer-documentation/08-CONTEXT.md (user decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LAYERS.md documentation</name>
  <files>docs/LAYERS.md</files>
  <action>
Create a comprehensive LAYERS.md file with the following structure:

1. **Header** with version, purpose, and quick reference table (L1/L2/L3/NEVER/DELETE/REVIEW)

2. **Layer Definitions** — For each layer:
   - Purpose (who uses it, what for)
   - Git status (tracked/gitignored)
   - Distribution channel (npm/private repo/local only)
   - Content types with REAL examples from AUDIT-REPORT.json

3. **Classification Criteria** (table format):
   | Criteria | L1 | L2 | L3 | NEVER | DELETE |
   |----------|----|----|----|----|--------|
   - Empty structures (.gitkeep) → L1
   - Core engine code → L1
   - Populated content (dossiers, playbooks) → L2
   - User-generated data (inbox, logs) → L3
   - Secrets, credentials → NEVER
   - Obsolete (finance-agent, talent-agent) → DELETE

4. **Decision Flowchart** (ASCII):
   ```
   Is it secrets/credentials? → YES → NEVER
                              → NO ↓
   Is it obsolete? → YES → DELETE
                   → NO ↓
   Is it user-generated content? → YES → L3
                                 → NO ↓
   Is it populated knowledge? → YES → L2
                              → NO ↓
   Is it core engine/template? → YES → L1
                               → NO → REVIEW
   ```

5. **Path Examples** (real from audit):
   - `core/` → L1 (Core engine)
   - `inbox/` → L3 (Personal data)
   - `.env` → NEVER (Secrets)
   - `archive/**/finance-agent/` → DELETE (Obsolete)
   - `knowledge/dossiers/persons/*.md` → L2 (Populated content)
   - `knowledge/dossiers/persons/.gitkeep` → L1 (Empty structure)

6. **How to Classify a New File** (practical guide):
   - Step 1: Check against NEVER patterns
   - Step 2: Check against DELETE patterns
   - Step 3: Determine content type (empty/populated/user)
   - Step 4: Apply layer rules
   - Step 5: If unclear → REVIEW

7. **Reference** — Link to `audit_layers.py` for programmatic classification

Use Markdown formatting with tables, code blocks, and ASCII diagrams.
  </action>
  <verify>
File exists and has all 7 sections:
```bash
grep -E "^## " docs/LAYERS.md | wc -l
```
Should return >= 7 sections
  </verify>
  <done>LAYERS.md exists with complete layer definitions, classification criteria, decision flowchart, and practical guide</done>
</task>

<task type="auto">
  <name>Task 2: Create .gitignore templates per layer</name>
  <files>
docs/audit/L1-GITIGNORE-TEMPLATE.txt
docs/audit/L2-GITIGNORE-TEMPLATE.txt
docs/audit/L3-GITIGNORE-TEMPLATE.txt
  </files>
  <action>
Create three .gitignore template files based on existing .gitignore patterns:

**L1-GITIGNORE-TEMPLATE.txt** (for npm package distribution):
- Header: `# L1 Community - gitignore for npm package`
- Purpose: Exclude L2, L3, NEVER content — keep only core engine
- Include patterns for:
  - All L2 content (populated knowledge, cargo agents with data)
  - All L3 content (inbox/**, logs/**, sessions)
  - All NEVER content (.env, credentials, secrets)
  - Build/deps (node_modules, __pycache__, .venv)
  - OS artifacts (.DS_Store, Thumbs.db)
- Note: This EXTENDS .npmignore, not replaces it

**L2-GITIGNORE-TEMPLATE.txt** (for premium repo):
- Header: `# L2 Premium - gitignore for premium distribution`
- Purpose: Exclude L3, NEVER content — keep L1 + L2
- Include patterns for:
  - All L3 content (inbox actual files, logs with content)
  - All NEVER content (.env, credentials, secrets)
  - User-specific runtime (.claude/sessions, .claude/jarvis)
  - Build/deps

**L3-GITIGNORE-TEMPLATE.txt** (for personal backup):
- Header: `# L3 Personal - gitignore for personal backup`
- Purpose: Exclude only NEVER content — keep everything else
- Include patterns for:
  - Only NEVER content (.env, credentials, secrets, tokens)
  - Large binary files (*.mp4, *.wav — optional, size-based)
  - Build artifacts (node_modules, dist, __pycache__)
- Note: This is the most permissive — personal backup includes L1+L2+L3

Extract patterns from existing .gitignore, grouping by layer purpose.
Use comments to explain each section.
  </action>
  <verify>
All three template files exist:
```bash
ls -la docs/audit/L{1,2,3}-GITIGNORE-TEMPLATE.txt 2>/dev/null | wc -l
```
Should return 3
  </verify>
  <done>Three .gitignore templates created with layer-appropriate exclusion patterns</done>
</task>

<task type="auto">
  <name>Task 3: Validate documentation completeness</name>
  <files>docs/LAYERS.md</files>
  <action>
Validate that LAYERS.md meets success criteria:

1. **Check section completeness:**
   - Verify all 7 sections exist
   - Verify each layer (L1, L2, L3, NEVER, DELETE, REVIEW) is documented

2. **Check real examples:**
   - Verify examples match AUDIT-REPORT.json classifications
   - Verify at least 3 examples per layer from actual audit

3. **Check decision flowchart:**
   - Verify flowchart covers all 6 categories
   - Verify flowchart is ASCII-rendered (copy-pasteable)

4. **Check practical guide:**
   - Verify step-by-step classification process exists
   - Verify "REVIEW" fallback is documented

5. **Check cross-references:**
   - Verify link to audit_layers.py exists
   - Verify link to AUDIT-REPORT.md exists

Add a "Validation Checklist" section at the end of LAYERS.md confirming these checks.
  </action>
  <verify>
LAYERS.md contains validation section:
```bash
grep -c "Validation Checklist" docs/LAYERS.md
```
Should return 1
  </verify>
  <done>LAYERS.md validated with completeness checklist, meeting "any person can classify" success criteria</done>
</task>

</tasks>

<verification>
Phase 08 is complete when:
1. `docs/LAYERS.md` exists with >= 150 lines and all required sections
2. Three `.gitignore` templates exist in `docs/audit/`
3. A person unfamiliar with the project can read LAYERS.md and correctly classify:
   - `core/tasks/new-task.md` → L1 (Core engine)
   - `knowledge/playbooks/SALES-PLAYBOOK.md` → L2 (Populated content)
   - `inbox/my-video.txt` → L3 (Personal data)
   - `.env.local` → NEVER (Secrets)
</verification>

<success_criteria>
- LAYERS.md is complete and self-contained
- .gitignore templates are ready for use in distribution repos
- Classification criteria are unambiguous with real examples
- Decision flowchart provides clear path for any file type
</success_criteria>

<output>
After completion, create `.planning/phases/08-layer-documentation/08-01-SUMMARY.md`
</output>
