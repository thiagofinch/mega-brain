---
phase: 09-layer-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/intelligence/validate_layers.py
  - docs/audit/VALIDATION-REPORT.json
  - docs/audit/VALIDATION-REPORT.md
autonomous: true
requirements:
  - VAL-01
  - VAL-02
  - VAL-03

must_haves:
  truths:
    - "Running `python3 core/intelligence/validate_layers.py` exits with code 0 against the current repo"
    - "Running with `--report` generates VALIDATION-REPORT.json and VALIDATION-REPORT.md in docs/audit/"
    - "Violations are detected when L3/NEVER files appear in git index (git ls-files catches them)"
    - "Script can be invoked from any directory and resolves repo root automatically (same as audit_layers.py)"
    - "VALIDATION-REPORT.md shows zero violations for the current clean state of the repo"
  artifacts:
    - core/intelligence/validate_layers.py
    - docs/audit/VALIDATION-REPORT.json
    - docs/audit/VALIDATION-REPORT.md
  key_links:
    - "validate_layers.py imports classify_path and scan_repository from audit_layers.py (same package, no install needed — use importlib or sys.path)"
    - "Exit code 0 = no violations (CI passes), exit code 1 = violations found (CI fails)"
    - "Violation definition: a file classified as L3 or NEVER that is tracked by git (appears in `git ls-files`)"
---

<objective>
Create a layer validation script that checks classification conformance across the repository, identify current violations, and generate a conformance report. The script wraps the existing `audit_layers.py` classification logic rather than duplicating it.

Purpose: Provide a CI-runnable gate that prevents L3/NEVER content from being accidentally committed to tracked git repos, and surfaces any REVIEW items as warnings.
Output: `validate_layers.py` (the validator), `VALIDATION-REPORT.json` + `VALIDATION-REPORT.md` (current state).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

Key prior work:
- `core/intelligence/audit_layers.py` — classifies every file in repo (L1/L2/L3/NEVER/DELETE/REVIEW). Functions: `classify_path(path, repo_root, is_file) -> (layer, reason)` and `scan_repository(repo_root, verbose) -> Dict`.
- `docs/LAYERS.md` — human-readable rules for each layer. Violation definition is there.
- `docs/audit/AUDIT-REPORT.json` — last full scan result (20,797 items: L1=658, L2=2546, L3=5384, NEVER=16, DELETE=10, REVIEW=12183).

<interfaces>
<!-- Key functions from core/intelligence/audit_layers.py — use these directly, do not rewrite -->

classify_path(path: Path, repo_root: Path, is_file: bool) -> Tuple[str, str]
    # Returns (layer, reason). Priority: DELETE > NEVER > L3 > L2 > L1 > REVIEW
    # Layers: "L1", "L2", "L3", "NEVER", "DELETE", "REVIEW"

scan_repository(repo_root: Path, verbose: bool = False) -> Dict
    # Returns: {generated_at, repo_root, summary: {total_items, by_layer}, classifications, delete_candidates, review_needed}
    # classifications: [{path, layer, type, reason}, ...]

# Import pattern (both scripts are in core/intelligence/):
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent))
from audit_layers import classify_path, scan_repository, NEVER_PATTERNS, L3_PATTERNS
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate_layers.py</name>
  <files>core/intelligence/validate_layers.py</files>
  <action>
Create `core/intelligence/validate_layers.py` that validates layer classification conformance. The script must:

1. **Import from audit_layers.py** (same directory) using sys.path trick shown in interfaces block. Import: `classify_path`, `scan_repository`.

2. **Resolve repo root** the same way audit_layers.py does:
   ```python
   script_path = Path(__file__).resolve()
   repo_root = script_path.parent.parent.parent  # core/intelligence/ -> core/ -> mega-brain/
   ```

3. **Get git-tracked files** via subprocess:
   ```python
   import subprocess
   result = subprocess.run(
       ['git', 'ls-files'],
       capture_output=True, text=True, cwd=str(repo_root)
   )
   tracked_files = set(result.stdout.strip().splitlines())
   ```

4. **Violation detection logic** (VAL-02):
   - For each git-tracked file, call `classify_path(repo_root / f, repo_root, is_file=True)`
   - A **HARD VIOLATION** is: layer in ("L3", "NEVER") AND file is git-tracked
     - Rationale: L3/NEVER content must never be in git index
   - A **SOFT WARNING** is: layer == "DELETE" AND file is git-tracked
     - Rationale: DELETE items should be removed but aren't a security risk
   - REVIEW items tracked by git are **informational only** (not violations)

5. **Conformance report structure** (VAL-03):
   ```json
   {
     "generated_at": "...",
     "repo_root": "...",
     "git_tracked_files": 123,
     "violations": {
       "hard": [{"path": "...", "layer": "L3", "reason": "..."}],
       "soft": [{"path": "...", "layer": "DELETE", "reason": "..."}]
     },
     "warnings": {
       "review_tracked": [{"path": "...", "reason": "..."}]
     },
     "summary": {
       "hard_violation_count": 0,
       "soft_violation_count": 0,
       "review_tracked_count": 123,
       "status": "PASS"   // "PASS" if hard_violation_count == 0, else "FAIL"
     }
   }
   ```

6. **CLI interface** (VAL-01):
   ```
   python3 core/intelligence/validate_layers.py           # Validate only, print summary, exit 0/1
   python3 core/intelligence/validate_layers.py --report  # Validate + write JSON + MD to docs/audit/
   python3 core/intelligence/validate_layers.py --verbose # Print each checked file
   ```

7. **Exit codes**:
   - Exit 0: `summary.hard_violation_count == 0` (PASS — CI green)
   - Exit 1: `summary.hard_violation_count > 0` (FAIL — CI red)
   - Soft violations print as warnings but do NOT change exit code

8. **Markdown report** (`docs/audit/VALIDATION-REPORT.md`):
   - Header: `# Mega Brain Layer Validation Report`
   - Generated timestamp, repo root, git-tracked file count
   - Status badge: `✅ PASS` or `❌ FAIL`
   - Section: Hard Violations (table with path, layer, reason) or "No hard violations found."
   - Section: Soft Warnings (DELETE items still tracked)
   - Section: Review Items Tracked (count + first 20 paths)
   - Footer: how to fix violations (classify file correctly or add to .gitignore)

9. **main() function** structure:
   ```python
   def main():
       parser = argparse.ArgumentParser(description='Validate Mega Brain layer conformance')
       parser.add_argument('--report', action='store_true', help='Write report to docs/audit/')
       parser.add_argument('--verbose', action='store_true', help='Print each checked file')
       args = parser.parse_args()

       # resolve repo_root
       # get tracked files via git ls-files
       # classify each tracked file
       # build violation/warning lists
       # print summary
       # if --report: write JSON + MD
       # sys.exit(0 if no hard violations else 1)
   ```

Use only stdlib (os, sys, json, argparse, subprocess, pathlib, datetime) — same constraint as audit_layers.py.
  </action>
  <verify>
    <automated>cd /Users/thiagofinch/Documents/Projects/mega-brain && python3 core/intelligence/validate_layers.py && echo "EXIT_CODE: $?"</automated>
  </verify>
  <done>Script runs without error, prints a summary table showing violation counts, exits with code 0 (since current repo should have no hard violations — L3/NEVER items are gitignored).</done>
</task>

<task type="auto">
  <name>Task 2: Run validator and commit conformance report</name>
  <files>
    docs/audit/VALIDATION-REPORT.json
    docs/audit/VALIDATION-REPORT.md
  </files>
  <action>
Run the validator with `--report` to generate the conformance report, verify it shows PASS status, then commit everything.

Steps:
1. Run: `python3 core/intelligence/validate_layers.py --report`
   - Verify exit code is 0 (PASS)
   - Verify `docs/audit/VALIDATION-REPORT.json` exists and `summary.status == "PASS"` and `summary.hard_violation_count == 0`
   - Verify `docs/audit/VALIDATION-REPORT.md` exists and contains "✅ PASS"

2. If exit code is 0: proceed to commit.
   If exit code is 1: read the hard violations, diagnose why (e.g., a L3 file was accidentally committed in a prior phase), fix the underlying issue (add to .gitignore or unstage/remove), then re-run until PASS.

3. Commit both the script and the reports:
   - Stage: `core/intelligence/validate_layers.py`, `docs/audit/VALIDATION-REPORT.json`, `docs/audit/VALIDATION-REPORT.md`
   - Message: `feat(validation): add layer validation script with conformance report`

4. Create SUMMARY.md for this plan (see output section).
  </action>
  <verify>
    <automated>cd /Users/thiagofinch/Documents/Projects/mega-brain && python3 core/intelligence/validate_layers.py --report && python3 -c "import json; d=json.load(open('docs/audit/VALIDATION-REPORT.json')); assert d['summary']['status']=='PASS', f'Expected PASS, got {d[\"summary\"][\"status\"]}'; print('VALIDATION-REPORT.json: status=PASS ✅')" && grep -q "✅ PASS" docs/audit/VALIDATION-REPORT.md && echo "VALIDATION-REPORT.md: contains PASS ✅"</automated>
  </verify>
  <done>VALIDATION-REPORT.json has status="PASS" and hard_violation_count=0. VALIDATION-REPORT.md shows "✅ PASS". Both files committed to git. Script exits 0 when run against current repo.</done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# 1. Script exists and is runnable
python3 core/intelligence/validate_layers.py
# Expected: prints summary, exits 0

# 2. Report files exist
ls docs/audit/VALIDATION-REPORT.json docs/audit/VALIDATION-REPORT.md

# 3. Report shows PASS with zero hard violations
python3 -c "
import json
d = json.load(open('docs/audit/VALIDATION-REPORT.json'))
print(f'Status: {d[\"summary\"][\"status\"]}')
print(f'Hard violations: {d[\"summary\"][\"hard_violation_count\"]}')
print(f'Git-tracked files checked: {d[\"git_tracked_files\"]}')
assert d['summary']['status'] == 'PASS'
assert d['summary']['hard_violation_count'] == 0
print('✅ All checks passed')
"

# 4. Script usable as CI step (exit code behavior)
python3 core/intelligence/validate_layers.py; echo "Exit code: $?"
# Expected: Exit code: 0
```
</verification>

<success_criteria>
1. `core/intelligence/validate_layers.py` exists and runs without error
2. Script exits 0 against current repository (zero hard violations)
3. `docs/audit/VALIDATION-REPORT.json` exists with `summary.status = "PASS"` and `summary.hard_violation_count = 0`
4. `docs/audit/VALIDATION-REPORT.md` is human-readable and shows ✅ PASS status
5. Script can be used as a CI step: `python3 core/intelligence/validate_layers.py` returns exit 0 on clean repo, exit 1 when violations present
6. All three requirements covered: VAL-01 (script), VAL-02 (violation detection), VAL-03 (conformance report)
</success_criteria>

<output>
After completion, create `.planning/phases/09-layer-validation/09-01-SUMMARY.md` with:
- What was built (validate_layers.py capabilities)
- Validation result (PASS/FAIL, violation counts)
- Files committed
- How to use in CI (one-liner command)
</output>
